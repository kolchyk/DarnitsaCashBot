# Руководство по потоку и настройке Telegram-бота

Это руководство описывает, как настроить взаимодействие с Telegram и как оно согласуется с backend-потоком, который обеспечивает работу `DarnitsaCashBot`. Оно основано на требованиях MVP из `prd.md`, деталях выплат из `portmone_setup.md` и ожиданиях по OCR из `OCR.md`, а также на текущей реализации под `apps/telegram_bot`, `apps/api_gateway` и сервисами в `services/`.

## 1. Область применения и предварительные требования

- **Основная цель**: автоматизировать процесс "чек на вход → выплата на выход" для украинских покупателей, награждая каждый принятый чек Darnitsa пополнением мобильного счета на 1 UAH.
- **Основополагающие документы**: держите открытыми `prd.md`, `OCR.md` и `portmone_setup.md` при работе с ботом для проверки предположений (окно приемлемости, задержка выплат, защита от мошенничества).
- **Инфраструктура**: PostgreSQL, локальное файловое хранилище и доступ к PortmoneDirect должны быть готовы перед включением бота; отдельные очереди/воркеры для OCR и правил больше не требуются.

## 2. Схема разговора в Telegram

### 2.1 Онбординг и согласие

1. `/start` (`apps/telegram_bot/handlers/commands.py::cmd_start`) приветствует пользователя и отображает кнопку `request_contact=True`, переведенную через `libs.common.i18n`.
2. Обработчик немедленно вызывает `ReceiptApiClient.register_user()` для вставки/обновления записи пользователя с локалью и телефоном, если Telegram уже предоставил их.
3. Без номера телефона выплаты блокируются. UX должен продолжать запрашивать контактные данные (см. `handle_contact`), пока не появится `Receipt.phone_number`.
4. Текст условий/конфиденциальности, упомянутый в `prd.md`, должен быть добавлен в приветственное сообщение или отправлен как последующий шаблон, если юридический отдел требует явного логирования согласия.

### 2.2 Команды и состояния

| Команда | Обработчик | Назначение |
| --- | --- | --- |
| `/start` | `commands.cmd_start` | Запуск онбординга, отображение контактной клавиатуры, регистрация пользователя. |
| `/help` | `commands.cmd_help` | Объяснение механики награды в 1 UAH и выделение `/history` + `/change_phone`. |
| `/history` | `commands.cmd_history` | Получение последних чеков через `/bot/history/{telegram_id}` и отображение ссылок на Portmone (bill_id + статус). |
| `/change_phone` | `commands.cmd_change_phone` | Повторное открытие контактной клавиатуры. Запуск `handle_contact` при нажатии пользователем. |

Хранение состояния (телефон, локаль, последние статусы) находится в backend БД; бот остается stateless, кроме внедренного `ReceiptApiClient`.

### 2.3 UX отправки чека

1. `media.handle_receipt_photo` прослушивает `Message.photo`.
2. Бот проверяет размер изображения как на стороне клиента (`photo.file_size <= 10 MB`), так и на стороне сервера (`apps/api_gateway/routes/bot.py::upload_receipt` повторно проверяет `MAX_FILE_SIZE` и MIME-тип).
3. Бот отвечает "Обрабатываю ваш чек…" и передает байты в `/bot/receipts` (multipart upload, см. `ReceiptApiClient.upload_receipt`).
4. API-шлюз сохраняет файл в объектном хранилище и возвращает начальный статус БД, который бот повторяет обратно.
5. Нефото-данные попадают в `fallback_handler`, поддерживая чистоту чата и направляя пользователей обратно к `/help`.

### 2.4 Локализация и поддержка текстов

- Aiogram использует gettext; вызовы перевода оборачивают каждую строку через `get_translator` и файлы `.po` под `apps/telegram_bot/locales/uk|ru/LC_MESSAGES`.
- Обновляйте тексты, редактируя файлы `.po` и перекомпилируя каталоги через `poetry run pybabel compile`.
- Локаль по умолчанию берется из `Message.from_user.language_code[:2]`, поэтому украинский — по умолчанию, русский — резервный, английский можно добавить позже согласно `prd.md`.

### 2.5 Защитные механизмы и ограничения

- `apps/api_gateway/dependencies.get_receipt_rate_limiter` ограничивает загрузки до **5 в минуту на Telegram ID**, используя простой in-memory счетчик — внешнее кэширование больше не требуется.
- `services/rules_engine/service.py` применяет **максимум 3 принятых чека на пользователя в день** (`MAX_RECEIPTS_PER_DAY`) и отклоняет чеки старше **7 дней** от временной метки покупки OCR.
- `prd.md` также указывает разрешение изображения (≥600 px короткая сторона) и рабочий процесс ручной проверки; расширьте ответы `media.handle_receipt_photo`, если добавляете клиентские эвристики (например, предупреждение о размытых изображениях).

## 3. Поток обработки в Backend

| Шаг | Компонент и файл | Описание |
| --- | --- | --- |
| 1. Прием | `apps/api_gateway/routes/bot.py::upload_receipt` | Сохраняет пользователя + чек, пишет файл на локальный диск через `StorageClient`, логирует аналитические события. |
| 2. OCR | `services/ocr_worker/worker.py` | Обрабатывает чеки и выполняет OCR прямо в процессе API (детекция QR + Tesseract/парсинг), результат сохраняет в `Receipt`. |
| 3. Приемлемость | `services/rules_engine/service.py` | Загружает алиасы каталога (`CatalogRepository`), запускает `is_receipt_eligible`, записывает `LineItem`s, обновляет статус на `accepted` или `rejected`. |
| 4. Оркестрация бонусов | `services/bonus_service/main.py` | При `status=accepted` расшифровывает MSISDN, создает/обновляет `BonusTransaction`, отправляет в PortmoneDirect (см. `portmone_setup.md`), обновляет статусы, отправляет аналитику. |

Каждый переход сохраняет корреляционную нагрузку (`receipt_id`, `user_id`, `telegram_id`, `checksum`), чтобы логи можно было отслеживать от начала до конца.

## 4. Ожидания по OCR и приемлемости

- Следуйте детальной предобработке + настройке Tesseract в `OCR.md` (выравнивание, адаптивная пороговая обработка, `ukr+rus+eng`, пороги уверенности). При необходимости интеграции с внешним OCR-провайдером обновите `services/ocr_worker/receipt_scraper.py` соответственно.
- Сохраняйте сырой OCR JSON в `Receipt.ocr_payload` (уже сделано в `ocr_worker`). Поддерживайте порог уверенности 0.8 и очередь ручной проверки, описанную в `OCR.md`; расширьте `services/rules_engine` для публикации кодов `reason`, когда требуется эскалация.
- Дедупликация в настоящее время использует SHA-256 загруженных байтов плюс логику `ReceiptRepository`; убедитесь, что алиасы каталога остаются обновленными (`libs/data/models/catalog.py`), чтобы `is_receipt_eligible` отражал маркетинговый список SKU.

## 5. Поток выплат и уведомлений

1. `bonus_service` расшифровывает `User.phone_number` через `libs.common.crypto.Encryptor` и сохраняет сумму 1 UAH (код по умолчанию — `100`, при необходимости скорректируйте для представления копеек).
2. Сервис вызывает PortmoneDirect через `libs/common/portmone.py`, формируя `bills.create` только после `status=accepted`.
3. Ответы обновляют `BonusTransaction.payout_status` (`IN_PROGRESS` → `SUCCESS` / `FAILED`) и фиксируют `bonus.portmone_bill_id` для сверок и коллбеков.
4. События аналитики (`payout_success`, `payout_failure`) сейчас пишутся в журналы через `libs/common/analytics.py`, чтобы MVP обходился без внешних брокеров.

Если предпочтителен Portmone, следуйте разделу "Метод bills.create для пополнения телефона" в `portmone_setup.md`: вызовите `bills.create`, сохраните возвращенные ID счетов и дождитесь, пока callback-эндпоинт изменит статусы перед уведомлением пользователя.

## 6. Чеклист конфигурации и развертывания

1. **Telegram**
   - Установите `TELEGRAM_BOT_TOKEN`, опционально `TELEGRAM_WEBHOOK_URL` (режим webhook) или запустите polling через `apps/telegram_bot/main.py`.
   - Настройте ID администраторов через `TELEGRAM_ADMIN_IDS` для включения сотрудников поддержки в белый список.
2. **Персистентность**
   - Заполните секреты `POSTGRES_*` и запустите миграции (см. `libs/data/models/*`).
   - Укажите базову директорію для локального сховища через `STORAGE_BASE_DIR` (за замовчуванням `./storage`).
3. **Безопасность**
   - Сгенерируйте `ENCRYPTION_SECRET` (32 байта) для шифрования телефона.
   - Установите секреты JWT, если используются admin API.
4. **Внешние сервисы**
   - `PORTMONE_API_BASE`, `PORTMONE_LOGIN`, `PORTMONE_PASSWORD`, `PORTMONE_PAYEE_ID`, `PORTMONE_CERT_PATH`, `PORTMONE_WEBHOOK_TOKEN`.
   - URL эндпоинта OCR + учетные данные (обновите `ocr_worker` для использования продакшен-хоста).
5. **Порядок запуска**
   - Поднимите Postgres (локально или через Docker) → запустите `apps/api_gateway` (FastAPI) → запустите `apps/telegram_bot`.
6. **Базовый URL API чеков**
   - Переопределите `ReceiptApiClient(base_url=...)` в `apps/telegram_bot/main.py`, если API-шлюз не находится на `http://localhost:8000`.

## 7. Мониторинг, оповещения и восстановление

- **Метрики**: Отслеживайте `receipt_uploaded`, `receipt_accepted`, `receipt_rejected`, `payout_success`, `payout_failure`, частоту ошибок Portmone (`portmone_request_total`, `portmone_fail_total{code}`), задержку/уверенность OCR и задержки очередей, как указано в `prd.md` и `OCR.md`.
- **Логи**: Включите структурированное логирование через `configure_logging(settings.log_level)` везде; включайте `receipt_id`, `telegram_id` и ссылки на Portmone (`bill_id`, `contractNumber`) в каждую запись лога для ускорения реагирования на инциденты.
- **Предложения по оповещению**:
  - Частота сбоев OCR >5% за 5 минут.
  - Серия `status=fail` PortmoneDirect >3 или тишина webhook >30 секунд.
- **Общие шаги восстановления**:
  - **Чек застрял в `processing`**: перезапустите `services/ocr_worker.worker.process_message` для нужного `receipt_id` — функция теперь доступна напрямую из приложения.
  - **Ложные отрицания правил**: обновите алиасы каталога (`libs/data/models/catalog.py`) и повторно запустите `services/rules_engine` для затронутых чеков.
  - **Сбои выплат**: проверьте `BonusTransaction.payout_status` и `BonusTransaction.portmone_error_code`, повторите выплату при необходимости и уведомите поддержку, если простой Portmone превышает SLA.
  - **Задача напоминания**: реализация отложена; при необходимости запланируйте cron/worker, который будет пинговать пользователей, начавших `/start`, но не отправивших чек в течение 24 часов, как требует `prd.md`.

Держите этот документ обновленным всякий раз, когда изменяются обработчики, сервисы или внешние интеграции, чтобы команды операций, маркетинга и поддержки имели единый источник правды для опыта работы с ботом.
